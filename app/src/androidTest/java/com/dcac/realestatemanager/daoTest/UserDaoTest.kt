package com.dcac.realestatemanager.daoTest

import androidx.sqlite.db.SimpleSQLiteQuery
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.dcac.realestatemanager.daoTest.fakeData.DatabaseSetup
import com.dcac.realestatemanager.data.offlineDatabase.user.UserDao
import com.dcac.realestatemanager.daoTest.fakeData.fakeEntities.FakeUserEntity
import kotlinx.coroutines.runBlocking
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import kotlinx.coroutines.flow.first
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertTrue

@RunWith(AndroidJUnit4::class)
class UserDaoTest: DatabaseSetup() {

    private lateinit var userDao: UserDao

    private val user1 = FakeUserEntity.user1
    private val user2 = FakeUserEntity.user2
    private val user3 = FakeUserEntity.user3
    private val allUsersNotDeleted = FakeUserEntity.userEntityListNotDeleted
    private val allUsers = FakeUserEntity.userEntityList

    @Before
    fun setupDao() {

        userDao = db.userDao()
    }

    @Test
    fun getUserById_shouldReturnCorrectUser() = runBlocking {
        userDao.insertUser(user1)
        val result = userDao.getUserById(user1.id).first()
        assertEquals(user1, result)
    }

    @Test
    fun getUserByFirebaseUid_shouldReturnCorrectUser() = runBlocking {
        userDao.insertUser(user1)
        val result = userDao.getUserByFirebaseUid(user1.firebaseUid).first()
        assertEquals(user1, result)
    }


    @Test
    fun getUserByEmail_shouldReturnCorrectUser() = runBlocking {
        userDao.insertUser(user2)
        val result = userDao.getUserByEmail(user2.email).first()
        val expected = user2.copy(isSynced = false)
        assertEquals(expected, result)
    }

    @Test
    fun getAllUsers_shouldReturnAllUsersNotMarkAsDeleted() = runBlocking {
        userDao.insertAllUsers(allUsers)
        val result = userDao.getAllUsers().first()
        val expected = allUsersNotDeleted.map { it.copy(isSynced = false) }
        assertEquals(expected, result)
    }

    @Test
    fun getUserByIdIncludeDeleted_shouldReturnCorrectUser() = runBlocking {
        userDao.insertUser(user3)
        val result = userDao.getUserByIdIncludeDeleted(user3.id).first()
        assertEquals(user3, result)
    }

    @Test
    fun getAllUserIncludeDeleted_shouldReturnAllUsers() = runBlocking {
        userDao.insertAllUsers(allUsers)
        val result = userDao.getAllUserIncludeDeleted().first()
        val expected = allUsers.map { it.copy(isSynced = false) }
        assertEquals(expected, result)
    }

    @Test
    fun emailExists_shouldReturnTrueWhenEmailPresent() = runBlocking {
        userDao.insertAllUsers(allUsers)
        val result = userDao.emailExists("agent2@example.com").first()
        val expected = true
        assertEquals(expected, result)
    }

    @Test
    fun firstUserInsert_shouldInsertUserAndReturnGeneratedId() = runBlocking {
        val newUser = user1.copy(id = 0L, email = "new@example.com", firebaseUid = "new_uid")

        val generatedId = userDao.firstUserInsert(newUser)

        // Check ID is > 0 (i.e. auto-generated by Room)
        assertTrue(generatedId > 0)

        val insertedUser = userDao.getUserById(generatedId).first()

        assertNotNull(insertedUser)
        assertEquals("new@example.com", insertedUser?.email)
        assertEquals("Alice Smith", insertedUser?.agentName)
    }

    @Test
    fun firstUserInsert_shouldIgnoreIfEmailAlreadyExists() = runBlocking {
        userDao.insertUser(user1)

        val duplicate = user1.copy(id = 0L) // same email, id reset to force Room to autogen

        val result = userDao.firstUserInsert(duplicate)

        // If ignored, Room returns -1L
        assertEquals(-1L, result)
    }


    @Test
    fun insertUser_shouldInsertUser() = runBlocking {
        userDao.insertUser(user1)
        val result = userDao.getUserById(user1.id).first()
        assertEquals(user1, result)
    }

    @Test
    fun insertAllUsers_shouldInsertAllUsers() = runBlocking {
        userDao.insertAllUsers(allUsers)
        val result = userDao.getAllUsers().first()
        val expected = allUsersNotDeleted.map { it.copy(isSynced = false) }
        assertEquals(expected, result)
    }

    @Test
    fun updateUser_shouldUpdateUser() = runBlocking {
        userDao.insertUser(user2)
        val updatedUser = user2.copy(
            agentName = "Updated Name",
            email = "Updated Email",
            updatedAt = System.currentTimeMillis()
        )
        userDao.updateUser(updatedUser)
        val result = userDao.getUserById(user2.id).first()

        assertEquals("Updated Name", result?.agentName)
        assertEquals("Updated Email", result?.email)
        assertEquals(false, result?.isSynced)
        assertEquals(updatedUser.updatedAt, result?.updatedAt)
    }

    @Test
    fun markUserAsDeleted_shouldMarkUserAsDeleted() = runBlocking {
        userDao.insertUser(user2)
        userDao.markUserAsDeleted(user2.id, System.currentTimeMillis())
        val result = userDao.getUserById(user2.id).first()
        assertEquals(null, result)
    }

    @Test
    fun markAllUsersAsDeleted_shouldMarkAllUsersAsDeleted() = runBlocking {
        userDao.insertAllUsers(allUsers)
        userDao.markAllUsersAsDeleted(System.currentTimeMillis())
        val result = userDao.getAllUsers().first()
        assertTrue(result.all { it.isDeleted })
    }

    @Test
    fun deleteUser_shouldDeleteUser() = runBlocking {
        userDao.insertUser(user3)
        userDao.deleteUser(user3)
        val result = userDao.getUserByIdIncludeDeleted(user3.id).first()
        assertEquals(null, result)
    }

    @Test
    fun clearAllUsers_shouldClearAllUsers() = runBlocking {
        userDao.insertAllUsers(allUsers)
        userDao.markUserAsDeleted(allUsers[0].id, System.currentTimeMillis())

        userDao.clearAllUsersDeleted()

        val result = userDao.getAllUserIncludeDeleted().first()

        assertFalse(result.any { it.id == allUsers[0].id})
        assertFalse(result.any { it.id == allUsers[2].id })

        assertTrue(result.any { it.id == allUsers[1].id })

        assertEquals(1 , result.size)
    }

    @Test
    fun getUnSyncedUsers_shouldReturnOnlyUnsynced() = runBlocking {
        userDao.insertAllUsers(allUsers)

        val result = userDao.uploadUnSyncedUsers().first()
        val expected = allUsers.map { it.copy(isSynced = false) }
        assertEquals(expected, result)
    }

    @Test
    fun downloadUserFromFirebase_shouldInsertUser() = runBlocking {
        userDao.downloadUserFromFirebase(user1)
        val result = userDao.getUserById(user1.id).first()
        val expected = user1.copy(isSynced = true)
        assertEquals(expected, result)
    }

    //This test ensures that:
    //the Cursor is not null,
    //it contains data (when the database is not empty),
    //it is closed correctly (good practice).
    @Test
    fun getAllUserAsCursor_shouldReturnValidCursor() = runBlocking {
        userDao.insertAllUsers(allUsers)
        val query = SimpleSQLiteQuery("SELECT * FROM users")
        val cursor = userDao.getAllUsersAsCursor(query)
        assertNotNull(cursor)
        assertTrue(cursor.count > 0)
        cursor.close()
    }

}